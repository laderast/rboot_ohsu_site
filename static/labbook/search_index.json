[
["index.html", "Ready for R: Notebook Reference Chapter 1 Welcome to Ready for R! 1.1 Introduction to this gitbook 1.2 Acknowledgements", " Ready for R: Notebook Reference Aaron Coyner and Ted Laderas 2020-06-12 Chapter 1 Welcome to Ready for R! This course introduces you R by working through common tasks in data science: importing, manipulating, and visualizing data. R is a statistical and programming computer language widely used for a variety of applications. Before proceeding with these training materials, please ensure you have an RStudio.cloud account and can see the workspace. 1.1 Introduction to this gitbook This is a searchable website that serves as a reference for the Ready for R course. This gitbook is not meant to be a substitute for the Ready for R notebooks. In order to access those, please sign up at the website here: https://ready4r.netlify.app/mailing 1.2 Acknowledgements Written by Aaron Coyner and Ted Laderas. Based on the Intro to R materials from https://fredhutch.io (by Kate Hertweck) and the R-Bootcamp (by Jessica Minnier and Ted Laderas) Images gratefully used from Allison Horst and Garrick Aden-Buie "],
["part-1-functions-and-objects.html", "Chapter 2 Part 1: Functions and Objects 2.1 Learning Objectives 2.2 An Intro to R/RStudio 2.3 Vectors 2.4 Wrapping up 2.5 Assignment 2.6 Submitting your homework", " Chapter 2 Part 1: Functions and Objects 2.1 Learning Objectives By the end of this session, you should be able to: Work within the RStudio interface to run R code in an RMarkdown notebook Understand basic R syntax to use functions and assign values to objects Create and manipulate vectors and understand how R deals with missing data 2.2 An Intro to R/RStudio [Tour of R and R Notebooks] Help -&gt; Cheetsheets -&gt; RStudio IDE cheat sheet 2.2.1 Code Blocks Now that we have our notebook open, we’re ready to start. First thing of all, is the grey box below. [Play button] # basic math 4 + 5 ## [1] 9 Let’s learn how to read this code block. Everything that starts with a # is called a comment and is not code that runs. It is useful for making notes for youself Below it is the actual code. Try this one out. It’s the same code as above, but with no spaces. Does it still run? # same code as above, without spaces 4+5 ## [1] 9 2.2.2 Using Functions R includes functions for other types of math: # using a function: rounding numbers round(3.14) ## [1] 3 [function names and arguments, syntax] # using a function with more arguments round(3.14, digits = 1) ## [1] 3.1 [getting help] ?round [documentation and arguments] # can switch order of arguments round(digits = 1, x = 3.14) ## [1] 3.1 You may notice that boxes pop up as you type. These represent RStudio’s attempts to guess what you’re typing and share additional options. 2.2.3 Challenge 1: What does the function hist do? What are its main arguments? How did you determine this? 2.2.4 Assigning objects [objects and variables] # assigning value to an object weight_kg &lt;- 55 [assignment operator, object naming conventions] Now that the object has been assigned, we can reference that object by executing its name: # recall object weight_kg ## [1] 55 [using a variable] # multiple an object (convert kg to lb) 2.2 * weight_kg ## [1] 121 [assigning a new variable] # assign weight conversion to object weight_lb &lt;- 2.2 * weight_kg [environment panel] # reassign new value to an object weight_kg &lt;- 100 [changing variable values] [objects that use other objects don’t change] You can think of the names of objects like sticky notes. You have the option to place the sticky note (name) on any value you choose. You can pick up the sticky note and place it on another value, but you need to explicitly tell R when you want values assigned to certain objects. # remove object remove(weight_lb) [removing objects] You can clear the entire environment using the button at the top of the Environment panel with a picture of a broom. This may seem extreme, but don’t worry! We can re-create all the work we’ve already done by executing each line of code again. 2.2.5 Challenge 2: What is the value of each item at each step? (Hint, you can see the value of an object by typing in the name of the object, such as with the mass line below.) mass &lt;- 47.5 # 1. mass? mass ## [1] 47.5 width &lt;- 122 # 2. width? mass &lt;- mass * 2.0 # 3. mass? width &lt;- width - 20 #4. width? mass_index &lt;- mass/width # 5. mass_index? Make your answers here: 2.3 Vectors [creating vectors] [c is for combine] # assign vector ages &lt;- c(50, 55, 60, 65) # recall vector ages ## [1] 50 55 60 65 [learning things about vectors] # how many things are in object? length(ages) ## [1] 4 # what type of object? class(ages) ## [1] &quot;numeric&quot; # performing functions with vectors mean(ages) ## [1] 57.5 range(ages) ## [1] 50 65 [characters] # vector of body parts organs &lt;- c(&quot;lung&quot;, &quot;prostate&quot;, &quot;breast&quot;) In this case, each word is encased in quotation marks, indicating these are character data, rather than object names. 2.3.1 Challenge 3: Please answer the following questions about organs: How many values are in organs? What type of data is organs? get overview of organs Answers here: 2.3.2 Data types and Vectors character: sometimes referred to as string data, tend to be surrounded by quotes numeric: real or decimal numbers, sometimes referred to as “double” integer: a subset of numeric in which numbers are stored as integers logical: Boolean data (TRUE and FALSE) complex: complex numbers with real and imaginary parts (e.g., 1 + 4i) raw: bytes of data (machine readable, but not human readable) 2.3.3 Challenge 4: R tends to handle interpreting data types in the background of most operations. The following code is designed to cause some unexpected results in R. What is unusual about each of the following objects? num_char &lt;- c(1, 2, 3, &quot;a&quot;) num_logical &lt;- c(1, 2, 3, TRUE) char_logical &lt;- c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, TRUE) tricky &lt;- c(1, 2, 3, &quot;4&quot;) 2.3.4 Manipulating vectors # add a value to end of vector ages &lt;- c(ages, 90) # add value at the beginning ages &lt;- c(30, ages) # extracting second value organs[2] ## [1] &quot;prostate&quot; # excluding second value organs[-2] ## [1] &quot;lung&quot; &quot;breast&quot; # extracting first and third values organs[c(1, 3)] ## [1] &quot;lung&quot; &quot;breast&quot; 2.3.5 Missing data # create a vector with missing data heights &lt;- c(2, 4, 4, NA, 6) [NA is not a character] # calculate mean and max on vector with missing data mean(heights) ## [1] NA max(heights) ## [1] NA [ugh. na strikes again!] # add argument to remove NA mean(heights, na.rm = TRUE) ## [1] 4 max(heights, na.rm = TRUE) ## [1] 6 # remove incomplete cases na.omit(heights) ## [1] 2 4 4 6 ## attr(,&quot;na.action&quot;) ## [1] 4 ## attr(,&quot;class&quot;) ## [1] &quot;omit&quot; 2.3.6 Challenge: Complete the following tasks after creating this vector (Note: there are multiple solutions): (solutions here) Remove NAs on more_heights (assign it to the object more_heights_complete) Calculate the median() of more_heights_complete # create vector more_heights &lt;- c(63, 69, 60, 65, NA, 68, 61, 70, 61, 59, 64, 69, 63, 63, NA, 72, 65, 64, 70, 63, 65) # remove NAs # calculate the median 2.4 Wrapping up [R/Rstudio] [objects] [data types] 2.5 Assignment Object manipulation Create an object called agge that contains your age in years. Then reassign the object to a new object called age (e.g., correct the typo). Then remove the previous object from your environment and then calculate your age in days #create agge object #reassign agge value to age #remove agge object #Use math to calculate your age in days Vector manipulation (character data): Create a object called buildings representing a vector that contains four names of buildings on OHSU’s campus, including the building where you work (here’s a reference: https://www.ohsu.edu/visit/maps). Add Portland, Oregon to the beginning of the vector, and Phys Plant to the end of the vector subset the vector to show only the building in which you work. #create buildings object buildings &lt;- c() #Add &quot;Portland, Oregon&quot; to the beginning of buildings #Add &quot;Phys Plant&quot; to the end of buildings #subset buildings to show only your building buildings[] ## NULL Vector manipulation (numerical data): The following vector represents the number of vacation days possessed by various employees. How many employees are represented in the vector? How many vacation days total? vacation_days &lt;- c(5, 7, 20, 1, 0, 0, 12, 4, 2, 2, 2, 4, 5, 6, 7, 10, 4) #how many employees are represented in the vector? #how many vacation days total? 2.6 Submitting your homework Submit your part1-FIRSTNAME-LASTNAME.nb.html file in Sakai. To download it, click on the More gear icon, and click Export to download it to your computer. "],
["part-2-data-frames-reading-data-ggplot2.html", "Chapter 3 Part 2: data.frames, Reading Data, ggplot2 3.1 Learning Objectives 3.2 A note about Base R versus the Tidyverse 3.3 Importing spreadsheet-style data into R 3.4 data.frames 3.5 Introducing ggplot2 3.6 What you learned today: 3.7 Practice 3.8 Assignment (10 points)", " Chapter 3 Part 2: data.frames, Reading Data, ggplot2 In this session, we’ll continue our introduction to R by working with a large dataset that more closely resembles that which you may encounter while analyzing data for research. 3.1 Learning Objectives By the end of this session, you should be able to: Import spreadsheet-style data into R as a data.frame. Understand properties of data.frames, especially variables. Visualize numeric vectors in this dataset using ggplot2 3.2 A note about Base R versus the Tidyverse For the remainder of this course, we’ll be focusing on using functions from the tidyverse. It is set up as a library - functions someone else wrote that are not built into R. We’ll use a few libraries in this course. The Tidyverse is essentially a library of libraries – each contains functions that are either essential for or greatly simplify the process of data manipulation and visualization for data scientists. We have already installed the tidyverse for you. For reading excel files, we need also load up an additional library called readxl. #load the required libraries library(here) library(tidyverse) library(readxl) 3.3 Importing spreadsheet-style data into R knitr::include_graphics(here(&quot;image/project2.JPG&quot;)) Once you have your notebook open, let’s talk about its location. It is located where the project.rproj file. The location of this file (also called an “RProject” file) is always considered the root directory of the project. It’s where you start from that determines the file directory path for loading data. Since this notebook, part2.Rmd is in the same folder as the project.rproj file, then when we need to refer to data files, it is relative to the root folder. When you’re starting out, it’s best to keep your RMarkdown notebooks and files in the root folder. It will help prevent you from dealing with a lot of headaches. 3.3.1 A good place to put your data Take a look at the data/ folder, and where the tcga_clinical_data.xlsx file is. In our notebook, how do we refer to that file name? Since we’re in the root, we can refer to it as data/tcga_clinical_data.xlsx 3.3.2 Loading our excel file Now we can use a built-in function called read_excel() that will help us load our data into R: brca_clinical &lt;- read_excel(here(&quot;data/tcga_clinical_data.xlsx&quot;), sheet = 1, skip = 1, na = &quot;NA&quot; ) You can see the excel file here: https://docs.google.com/spreadsheets/d/1E6jmCB9nfeIJ_zlSH6HJCUmKwwcMTWwP0EwEcAHo0CU/edit?usp=sharing You should see brca_clinical appear in the Environment window on the upper right panel in RStudio. If you click on brca_clinical there, a new tab will appear next to your R script in the Source window. Clicking on the name of an object in the Environment window is a shortcut for running View(brca_clinical); you’ll see this code appear in the Console after clicking. 3.3.3 Challenge 1 (5 minutes) Take a look at the documentation for read_excel(). This is a package in the package readxl, which is installed as part of the tidyverse. What does the skip argument do? Do we need to refer to a sheet within an excel file as a number, or can we refer to it as the sheet name instead? What does the guess_max argument do? ?read_excel ## starting httpd help server ... done [Your answers here] Now that we have the data imported and assigned to an object, we can take some time to explore the data we’ll be using for the rest of this course. 3.3.4 Notes on the Data These data are clinical cancer data from the National Cancer Institute’s Genomic Data Commons, specifically from The Cancer Genome Atlas, or TCGA. Each row represents a patient, and each column represents information about demographics (race, age at diagnosis, etc) and disease (e.g., cancer type). The data were downloaded and aggregated using an R script, which you can view in the GitHub repository for this course. 3.3.5 Challenge 2 (5 minutes): Inspect, and import the following sheets from the tcga_clinical_data.xlsx excel file. Confirm that you have loaded them correctly by clicking on the objects in the Environment pane in the top right. The CESC sheet. Save it as cesc_clinical. The LUSC sheet. Save it as lusc_clinical. #load cesc_clinical here #What should be the sheet argument? #do you need to skip a line? cesc_clinical &lt;- read_excel(&quot;data/tcga_clinical_data.xlsx&quot;, sheet = ____, skip = ___ na = &quot;NA&quot; ) #load lusc_clinical here lusc_clinical &lt;- Importing data can be tricky and frustrating. However, if you can’t get your data into R, you can’t do anything to analyze or visualize it. It’s worth understanding how to do it effectively to save you time and energy later. We will be covering loading in another format that you can export from many different software programs, the comma separated value format, or csv format in another section. 3.3.6 Tips on Formating your excel file for R Here are some tips on formatting your data to get it into R easier. Click on the code block below to load up a graphic. knitr::include_graphics(&quot;image/tidy-1.png&quot;) Tidy is Best. Try to format your spreadsheet where the columns correspond to variables you’re measuring, and a row corresponds to an observation. In our example: each row corresponds to a patient each column corresponds to a variable of clinical data each cell has a value We’ll be seeing that this format is called Tidy Data, and it lets us do all sorts of things in R successfully. Transpose is your Friend in Excel.* If your data isn’t in this format, no worries! You can copy it to a new sheet and use the transpose option when you’re pasting it, and then load that in. Every column needs a name. Every one of your columns should be named at the top, and should begin with a letter. Numbers and special characters can cause errors in your data analysis pipeline. Color information is hard to get into R. Avoid using color coding of cells if that is extra information attached to a cell. Instead, make the information the color is representing its own column. Extra Lines are OK! Extra lines before the column header are ok, as you’ve seen. It’s sometimes better to have a “notes” sheet where you put extra information or, better yet, a data dictionary. 3.4 data.frames Now that we have data imported and available, we can start to inspect the data more closely. These data have been interpreted by R to be a data frame, which is a data structure (way of organizing data) that is analogous to tabular or spreadsheet style data. By definition, a data.frame is: a table made of vectors (columns) of all the same length. As we learned in our last session, a vector needs to include all of the same type of data (e.g., character, numeric). A data.frame, however, can include vectors (columns) of different data types. This makes them extremely versatile way of storing information. 3.4.1 data.frames - How do they Work? To learn more about this data frame, we’ll first explore its dimensions: # assess size of data frame dim(brca_clinical) ## [1] 1095 16 This output reflects the number of rows, then the number of columns. We can also preview the content by showing the first few rows: # preview first few rows head(brca_clinical) ## # A tibble: 6 x 16 ## submitter_id primary_diagnos~ tumor_stage disease age_at_diagnosis ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 TCGA-3C-AAAU C50.9 stage x BRCA 20211 ## 2 TCGA-3C-AALI C50.9 stage iib BRCA 18538 ## 3 TCGA-3C-AALJ C50.9 stage iib BRCA 22848 ## 4 TCGA-3C-AALK C50.9 stage ia BRCA 19074 ## 5 TCGA-4H-AAAK C50.9 stage iiia BRCA 18371 ## 6 TCGA-5L-AAT0 C50.9 stage iia BRCA 15393 ## # ... with 11 more variables: vital_status &lt;chr&gt;, morphology &lt;chr&gt;, ## # days_to_death &lt;dbl&gt;, days_to_birth &lt;dbl&gt;, ## # site_of_resection_or_biopsy &lt;chr&gt;, days_to_last_follow_up &lt;dbl&gt;, ## # gender &lt;chr&gt;, year_of_birth &lt;dbl&gt;, race &lt;chr&gt;, ethnicity &lt;chr&gt;, ## # year_of_death &lt;dbl&gt; 3.4.2 Column Names We often need to reference the names of variables (also known as columns) in our data.frame, so it’s useful to print only those to the screen: # view column names colnames(brca_clinical) ## [1] &quot;submitter_id&quot; &quot;primary_diagnosis&quot; ## [3] &quot;tumor_stage&quot; &quot;disease&quot; ## [5] &quot;age_at_diagnosis&quot; &quot;vital_status&quot; ## [7] &quot;morphology&quot; &quot;days_to_death&quot; ## [9] &quot;days_to_birth&quot; &quot;site_of_resection_or_biopsy&quot; ## [11] &quot;days_to_last_follow_up&quot; &quot;gender&quot; ## [13] &quot;year_of_birth&quot; &quot;race&quot; ## [15] &quot;ethnicity&quot; &quot;year_of_death&quot; It’s also possible to view row names usingrownames(brca_clinical), but our data only possess numbers for row names so it’s not very informative. 3.4.3 Okay, What’s really in it? We can use glimpse() to provide a general overview of the object: # show overview of data.frame glimpse(brca_clinical) ## Rows: 1,095 ## Columns: 16 ## $ submitter_id &lt;chr&gt; &quot;TCGA-3C-AAAU&quot;, &quot;TCGA-3C-AALI&quot;, &quot;TCGA-3... ## $ primary_diagnosis &lt;chr&gt; &quot;C50.9&quot;, &quot;C50.9&quot;, &quot;C50.9&quot;, &quot;C50.9&quot;, &quot;C5... ## $ tumor_stage &lt;chr&gt; &quot;stage x&quot;, &quot;stage iib&quot;, &quot;stage iib&quot;, &quot;s... ## $ disease &lt;chr&gt; &quot;BRCA&quot;, &quot;BRCA&quot;, &quot;BRCA&quot;, &quot;BRCA&quot;, &quot;BRCA&quot;,... ## $ age_at_diagnosis &lt;dbl&gt; 20211, 18538, 22848, 19074, 18371, 1539... ## $ vital_status &lt;chr&gt; &quot;alive&quot;, &quot;alive&quot;, &quot;alive&quot;, &quot;alive&quot;, &quot;al... ## $ morphology &lt;chr&gt; &quot;8520/3&quot;, &quot;8500/3&quot;, &quot;8500/3&quot;, &quot;8500/3&quot;,... ## $ days_to_death &lt;dbl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,... ## $ days_to_birth &lt;dbl&gt; -20211, -18538, -22848, -19074, -18371,... ## $ site_of_resection_or_biopsy &lt;chr&gt; &quot;C50.9&quot;, &quot;C50.9&quot;, &quot;C50.9&quot;, &quot;C50.9&quot;, &quot;C5... ## $ days_to_last_follow_up &lt;dbl&gt; 4047, 4005, 1474, 1448, 348, 1477, 1471... ## $ gender &lt;chr&gt; &quot;female&quot;, &quot;female&quot;, &quot;female&quot;, &quot;female&quot;,... ## $ year_of_birth &lt;dbl&gt; 1949, 1953, 1949, 1959, 1963, 1968, 194... ## $ race &lt;chr&gt; &quot;white&quot;, &quot;black or african american&quot;, &quot;... ## $ ethnicity &lt;chr&gt; &quot;not hispanic or latino&quot;, &quot;not hispanic... ## $ year_of_death &lt;dbl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,... The output provided by glimpse() includes: data structure: data.frame dimensions: column-by-column information: each prefaced with a $, and includes the column name, data type (num, int, Factor) Identify the numeric variables (they are noted as &lt;dbl&gt; or double). What are they? Another useful command is View() - it will open up a spreadsheet like view of our data_frame. You can also view this by clicking on the brca_clinical object in the Environment pane in the top-right. View(brca_clinical) 3.4.4 Summarizing our Data Finally, we can also examine basic summary statistics for each column: # provide summary statistics for each column summary(brca_clinical) ## submitter_id primary_diagnosis tumor_stage disease ## Length:1095 Length:1095 Length:1095 Length:1095 ## Class :character Class :character Class :character Class :character ## Mode :character Mode :character Mode :character Mode :character ## ## ## ## ## age_at_diagnosis vital_status morphology days_to_death ## Min. : 9706 Length:1095 Length:1095 Min. : 116.0 ## 1st Qu.:18032 Class :character Class :character 1st Qu.: 689.2 ## Median :21562 Mode :character Mode :character Median :1223.0 ## Mean :21587 Mean :1643.0 ## 3rd Qu.:24863 3rd Qu.:2370.0 ## Max. :32872 Max. :7455.0 ## NA&#39;s :16 NA&#39;s :945 ## days_to_birth site_of_resection_or_biopsy days_to_last_follow_up ## Min. :-32872 Length:1095 Min. : -31.0 ## 1st Qu.:-24863 Class :character 1st Qu.: 434.2 ## Median :-21562 Mode :character Median : 760.5 ## Mean :-21587 Mean :1187.2 ## 3rd Qu.:-18032 3rd Qu.:1583.2 ## Max. : -9706 Max. :8605.0 ## NA&#39;s :16 NA&#39;s :105 ## gender year_of_birth race ethnicity ## Length:1095 Min. :1902 Length:1095 Length:1095 ## Class :character 1st Qu.:1940 Class :character Class :character ## Mode :character Median :1950 Mode :character Mode :character ## Mean :1949 ## 3rd Qu.:1960 ## Max. :1984 ## NA&#39;s :1 ## year_of_death ## Min. :1992 ## 1st Qu.:2001 ## Median :2005 ## Mean :2004 ## 3rd Qu.:2008 ## Max. :2013 ## NA&#39;s :991 For numeric data (such as year_of_death), this output includes common statistics like median and mean, as well as the number of rows (patients) with missing data (as NA). For factors (also known as categorical variables), and character variables, such as disease, you’re given a count of the number of times the top six most frequent factors (categories) occur in the data frame. We will talk more about factors in the next lab. 3.5 Introducing ggplot2 Click the button below to load up the graphic. knitr::include_graphics(here(&quot;image/ggplot2_exploratory.png&quot;)) Now that we’ve loaded our data as a data.frame, we can begin to start doing things with it. Let’s start with visualizing the data. 3.5.1 Working Towards a Graph We’re going to work towards the following graph today: knitr::include_graphics(here(&quot;image/days_to_last_followup.png&quot;)) 3.5.2 ggplot2: A Grammar of Graphics ggplot2 is an extremely powerful software library for visualization. The gg is short for Grammar of Graphics, which means that visualizations are expressed in a very specific way. 3.5.3 Learning to read ggplot2 code A ggplot2 graphic consists of a: mapping of variables in data to aes()thetic attributes of geom_etric objects. In code, this is translated as: #start the plot with ggplot() ggplot(data = brca_clinical) + # make the mapping # map the x-axis to age_at_diagnosis aes( x = age_at_diagnosis, y = days_to_birth ) + # add the geometry geom_point() Things to note: we chain these three things together with + (plus sign). I tend to read the plus as then. [aes() function - mapping variables to visual properties of the graph] 3.5.4 Challenge Based on the graph above, map the appropriate variables in brca_clinical to the x, and y aesthetics. Run your plot. Is it what you expected? What’s missing compared to the graph above? ggplot(data = brca_clinical) + aes(x = _____ , y = _____ ) + geom_point() 3.5.5 Simple arithmetic Huh. age_at_diagnosis is in days, not years. We can fix that by dividing it by 365: ggplot(data = brca_clinical) + aes(x = age_at_diagnosis / 365 , y = days_to_last_follow_up ) + geom_point() ## Warning: Removed 120 rows containing missing values (geom_point). 3.5.6 Color We can also map a character variable to our graph to color. Try mapping gender to color. ggplot(data = brca_clinical) + aes(x = age_at_diagnosis / 365 , y = days_to_last_follow_up, color = _____) + geom_point() 3.5.7 Titles We can add more details to our graph. We can add a title using the labs() function: ggplot(data = brca_clinical) + aes(x = age_at_diagnosis / 365 , y = days_to_last_follow_up, color = gender) + geom_point() + labs(title=&quot;Age versus Days to Last followup&quot;) ## Warning: Removed 120 rows containing missing values (geom_point). 3.5.8 Changing the Axis Labels We can change the x-axis titles and the y-axis titles using the xlab() (short for x label) and ylab() functions: ggplot(data = brca_clinical) + aes(x = age_at_diagnosis / 365 , y = days_to_last_follow_up, color = gender) + geom_point() + ggtitle(&quot;Age versus Days to Last followup&quot;) + xlab(&quot;Age at Diagnosis (Years)&quot;) + ylab(&quot;Days to Follow Up&quot;) ## Warning: Removed 120 rows containing missing values (geom_point). Now we’ve re-created the above plot! Let’s save it using ggsave(). ggsave() saves the last created plot to a file. We’ll save it as a jpg file. ggsave() is smart enough to know that we want to save it as a jpg from adding the extension .jpg to our filename. ggsave(&quot;follow-up-plot.jpg&quot;) ## Saving 7 x 5 in image ## Warning: Removed 120 rows containing missing values (geom_point). 3.6 What you learned today: Loading excel data and tips for formatting your data in excel Understanding basic properties of data.frames The basics of the “grammar of graphics” with ggplot2 3.7 Practice You can practice your ggplot2 skills by taking the first chapter of the R-Bootcamp: https://r-bootcamp.netlify.com/chapter1 3.8 Assignment (10 points) Instructions: Turn your .nb.html file in with the following assignment finished. Make sure it is named part2_LASTNAME.nb.html, where LASTNAME is your last name, of course. Load the smoke_complete.xlsx file into R using read_excel. You’ll need to take a look at it to make sure that your arguments are correct. smoke_complete &lt;- read_excel() Use glimpse() on smoke_complete. How many rows does the file have? How many variables does it have? What are the numeric variables in this dataset? glimpse(smoke_complete) [Put your answer here] Produce a scatter plot of smoke_complete using geom_point(), mapping these variables to the following aesthetics: year_of_birth to the x aesthetic, cigarettes_per_day to the y aesthetic, and gender to the color aesthetic. ggplot(smoke_complete, aes(x = ____, y = ____, color = ___)) + Pick two numeric variables, and a character variable in the dataset and produce a scatterplot by mapping them to x, y, and color. Add a title and change the x and y labels to make sense. "],
["part-3-more-data-visualization-and-data-manipulation.html", "Chapter 4 Part 3: More Data Visualization and Data Manipulation 4.1 Learning Objectives 4.2 Getting set up 4.3 More about ggplot2 4.4 Brief Aside: Categorical Data (factors) 4.5 Back to ggplot2: Boxplots 4.6 Further learning 4.7 Data Manipulation using dplyr 4.8 What you learned today 4.9 Practice 4.10 Acknowledgements 4.11 Assignment 3", " Chapter 4 Part 3: More Data Visualization and Data Manipulation 4.1 Learning Objectives Create and modify scatterplots and boxplots Split figures into multiple panels using facet_wrap() Customize your plots using built in theme()s Sort by a variable in a dataset using arrange() Select variables in a dataset using select() Filter a dataset using the filter() function 4.2 Getting set up # load library library(tidyverse) library(readxl) library(here) smoke_complete &lt;- read_excel(here(&quot;data/smoke_complete.xlsx&quot;), sheet=1, na=&quot;NA&quot;) #remove some columns - we&#39;ll talk about this later smoke_complete &lt;- smoke_complete %&gt;% select(age_at_diagnosis, tumor_stage, cigarettes_per_day, gender, vital_status, disease) 4.3 More about ggplot2 4.3.1 Customizing a Scatterplot Now that we have the data generally displayed the way we’d like, we can start to customize a plot. our_plot &lt;- ggplot(smoke_complete) + aes(x = age_at_diagnosis, y = cigarettes_per_day, color = disease) + geom_point() + labs(title = &quot;Cigarettes per Day versus Age at Diagnosis&quot;, x = &quot;Age at Diagnosis&quot;, y = &quot;Cigarettes Smoked per Day&quot;) our_plot 4.3.2 Changing visual properties using built in themes our_plot + theme_minimal() A complete list of pre-set themes is available here, and we’ll cover ways to customize our own themes later in this lesson. 4.3.3 Using theme() to customize Adding the theme() function will let us customize our plot further. There are a few arguments that are really helpful to modify: axis.title axis.title.x axis.title.y (The labels for the axes) legend.position (Placing the legend, including removing it) our_plot + theme_bw() + theme(axis.text.x = element_text(angle = 90)) our_plot + theme_bw() + theme(legend.position = &quot;none&quot;) 4.3.4 Saving your work After you’re satisfied with a plot, it’s likely you’d want to share it with other people or include in a manuscript or report. # save plot to file ggsave(&quot;awesomePlot.jpg&quot;, width = 10, height = 10, dpi = 300) This automatically saves the last plot for which code was executed. This command interprets the file format for export using the file suffix you specify. The other arguments dictate the size (width and height) and resolution (dpi). 4.4 Brief Aside: Categorical Data (factors) One data type that we haven’t yet looked at are factors - factors are how R represents categorical data. For the most part, you can use character and factors interchangably for categorical data. However, there is one main difference. factors define the permissible values in a vector with an argument called levels. They also define the order in which these values are displayed. character_vector &lt;- c(&quot;Dog&quot;, &quot;Dog&quot;, &quot;Cat&quot;, &quot;Mouse&quot;) table(character_vector) ## character_vector ## Cat Dog Mouse ## 1 2 1 You can make a character vector into a factor vector by using the factor() function, and supplying an argument called levels. 4.4.1 Levels of a Factor The levels of a factor are the permissible values in a factor. The order of the values in a factor also control the order in which the values appear in tables and on the axes in a plot. So, you can control the order of the categories in a factor by specifying the order of the categories in the levels argument. factor_vector &lt;- factor(character_vector, levels = c(&quot;Dog&quot;, &quot;Cat&quot;, &quot;Mouse&quot;)) table(factor_vector) ## factor_vector ## Dog Cat Mouse ## 2 1 1 This ordering is the main reason to use factors. We will revisit this again in Part 4 when we learn how to manipulate the data type of a variable in a data.frame. 4.5 Back to ggplot2: Boxplots Boxplots compare the distribution of a quantitative variable among categories. Remember, vital_status is a character vector, but we’re not too worried about the implicit order of the categories, so we can use it as is in our boxplot. # creating a boxplot ggplot(smoke_complete) + aes(x = vital_status, y = cigarettes_per_day) + geom_boxplot() The main differences from the scatterplots we created earlier are the geom type and the variables plotted. We can change the color similarly to scatterplots. However, we map to fill and not color: # adding color ggplot(smoke_complete) + aes(x = vital_status, y = cigarettes_per_day, fill = vital_status) + geom_boxplot() 4.5.1 Faceting our boxplot One of the most powerful ways to change a visualization is by faceting. We can make multiple plots using another categorical variable. To do this, we have to add the facet_wrap() command to our plot. We need to specify the variable to facet_wrap - disease by using the vars() function to specify it as a variable. # adding color ggplot(smoke_complete) + aes(x = vital_status, y = cigarettes_per_day, fill = vital_status) + geom_boxplot() + ylim(c(0,20)) + facet_wrap(vars(disease)) ## Warning: Removed 1 rows containing non-finite values (stat_boxplot). Don’t forget to look at the help documentation (e.g., ?facet_wrap) to learn more about additional ways to customize your plots! 4.6 Further learning If you are interested in learning more about ggplot: - Documentation for all ggplot features is available here. - RStudio also publishes a ggplot cheat sheet that is really handy! 4.7 Data Manipulation using dplyr What we have learned is pretty great overall for plotting. But there are a lot of other things we can do with data.frames! We’re going to talk about another tidyverse package: dplyr. dplyr is your all-purpose toolbox for filtering, summarizing, and transforming data. The nice thing about dplyr is that it is focused on verbs that do things to your data. We’ll focus on the following verbs: arrange() - sorting a data.frame by a variable filter() - subsetting a data.frame by criteria select() - returning only a few columns from our data.frame group_by()/summarize() - summarizing our data.frame, such as counting and computing means mutate() - transforming variables in our data %&gt;% - the pipe character, which lets us join our verbs together in a pipeline. 4.7.1 Introducing the pipe (%&gt;%) Often times, we want to do multiple operations on our data and in a specific order. For example, I might want to do the following: Take my dataset smoke_complete and then Sort it by cigarettes_per_day and then filter to have only males from the data. The pipe (%&gt;%) function acts like the and then: # Take my dataset smoke complete **and then** smoke_complete %&gt;% #sort it by cigarettes_per day **and then** arrange(cigarettes_per_day) %&gt;% #filter it to only have males filter(gender == &quot;male&quot;) ## # A tibble: 786 x 6 ## age_at_diagnosis tumor_stage cigarettes_per_day gender vital_status disease ## &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 18051 stage iii 0.00822 male dead BLCA ## 2 29288 stage iii 0.0548 male dead BLCA ## 3 18983 stage ii 0.0822 male dead BLCA ## 4 22632 stage iiia 0.110 male dead LUSC ## 5 20632 stage iib 0.110 male alive LUSC ## 6 25579 stage iii 0.110 male dead BLCA ## 7 22632 stage iiia 0.110 male dead LUSC ## 8 20632 stage iib 0.110 male alive LUSC ## 9 23156 stage i 0.137 male dead LUSC ## 10 13867 stage ii 0.137 male alive BLCA ## # ... with 776 more rows You can think of a pipe as putting the output of one step as an input of another. These two statements are equivalent: smoke_complete %&gt;% arrange(cigarettes_per_day) ## # A tibble: 1,152 x 6 ## age_at_diagnosis tumor_stage cigarettes_per_day gender vital_status disease ## &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 18051 stage iii 0.00822 male dead BLCA ## 2 19847 not reported 0.0110 female alive CESC ## 3 14225 not reported 0.0219 female dead CESC ## 4 31258 not reported 0.0312 female alive CESC ## 5 16429 stage iii 0.0548 female dead LUSC ## 6 27449 stage ii 0.0548 female dead LUSC ## 7 29288 stage iii 0.0548 male dead BLCA ## 8 15965 not reported 0.0548 female alive CESC ## 9 17465 not reported 0.0548 female dead CESC ## 10 15849 not reported 0.0548 female alive CESC ## # ... with 1,142 more rows and arrange(smoke_complete, cigarettes_per_day) ## # A tibble: 1,152 x 6 ## age_at_diagnosis tumor_stage cigarettes_per_day gender vital_status disease ## &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 18051 stage iii 0.00822 male dead BLCA ## 2 19847 not reported 0.0110 female alive CESC ## 3 14225 not reported 0.0219 female dead CESC ## 4 31258 not reported 0.0312 female alive CESC ## 5 16429 stage iii 0.0548 female dead LUSC ## 6 27449 stage ii 0.0548 female dead LUSC ## 7 29288 stage iii 0.0548 male dead BLCA ## 8 15965 not reported 0.0548 female alive CESC ## 9 17465 not reported 0.0548 female dead CESC ## 10 15849 not reported 0.0548 female alive CESC ## # ... with 1,142 more rows One big advantage of the pipe is that you can build your processing line by line. In practice, as I work, I will often pipe things into View() to confirm I did things correctly: smoke_complete %&gt;% arrange(cigarettes_per_day) %&gt;% View() 4.7.2 The difference between + and %&gt;% Remember that + is for ggplot2 and that %&gt;% is for dplyr. To keep them distinct and avoid confusion, separate our your data processing and your plotting: arranged_smokers &lt;- smoke_complete %&gt;% filter(gender == &quot;male&quot;) ggplot(data=arranged_smokers) + aes(x = cigarettes_per_day) + geom_histogram() ## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. 4.7.3 Sorting Data Frames using arrange() Ok, we already have encountered arrange(). It’s a function that lets us sort a data.frame by a variable. By default, it sorts in ascending order: smoke_complete %&gt;% arrange(cigarettes_per_day) ## # A tibble: 1,152 x 6 ## age_at_diagnosis tumor_stage cigarettes_per_day gender vital_status disease ## &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 18051 stage iii 0.00822 male dead BLCA ## 2 19847 not reported 0.0110 female alive CESC ## 3 14225 not reported 0.0219 female dead CESC ## 4 31258 not reported 0.0312 female alive CESC ## 5 16429 stage iii 0.0548 female dead LUSC ## 6 27449 stage ii 0.0548 female dead LUSC ## 7 29288 stage iii 0.0548 male dead BLCA ## 8 15965 not reported 0.0548 female alive CESC ## 9 17465 not reported 0.0548 female dead CESC ## 10 15849 not reported 0.0548 female alive CESC ## # ... with 1,142 more rows To sort by descending order, you need to wrap the variable in the desc() function: smoke_complete %&gt;% arrange(desc(cigarettes_per_day)) ## # A tibble: 1,152 x 6 ## age_at_diagnosis tumor_stage cigarettes_per_day gender vital_status disease ## &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 17635 stage iv 40 male dead BLCA ## 2 27708 stage ia 13.2 male dead LUSC ## 3 27708 stage ia 13.2 male dead LUSC ## 4 24477 stage ia 11.0 male dead LUSC ## 5 24477 stage ia 11.0 male dead LUSC ## 6 24713 stage iiia 10.5 male dead LUSC ## 7 24713 stage iiia 10.5 male dead LUSC ## 8 25646 stage ib 9.86 male alive LUSC ## 9 25646 stage ib 9.86 male alive LUSC ## 10 25506 stage ib 8.88 male alive LUSC ## # ... with 1,142 more rows You can also arrange by multiple variables. smoke_complete %&gt;% arrange(desc(cigarettes_per_day), tumor_stage) ## # A tibble: 1,152 x 6 ## age_at_diagnosis tumor_stage cigarettes_per_day gender vital_status disease ## &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 17635 stage iv 40 male dead BLCA ## 2 27708 stage ia 13.2 male dead LUSC ## 3 27708 stage ia 13.2 male dead LUSC ## 4 24477 stage ia 11.0 male dead LUSC ## 5 24477 stage ia 11.0 male dead LUSC ## 6 24713 stage iiia 10.5 male dead LUSC ## 7 24713 stage iiia 10.5 male dead LUSC ## 8 25646 stage ib 9.86 male alive LUSC ## 9 25646 stage ib 9.86 male alive LUSC ## 10 25506 stage ib 8.88 male alive LUSC ## # ... with 1,142 more rows Note that order of variables in arrange() matters! smoke_complete %&gt;% arrange( tumor_stage, desc(cigarettes_per_day) ) ## # A tibble: 1,152 x 6 ## age_at_diagnosis tumor_stage cigarettes_per_day gender vital_status disease ## &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 25220 not reported 3.12 female alive CESC ## 2 28873 not reported 3.07 female dead CESC ## 3 18773 not reported 2.90 female alive CESC ## 4 16231 not reported 2.85 female dead CESC ## 5 24059 not reported 2.74 female dead CESC ## 6 20302 not reported 2.74 female alive CESC ## 7 28826 not reported 2.47 male dead LUSC ## 8 28826 not reported 2.47 male dead LUSC ## 9 21520 not reported 2.19 female dead CESC ## 10 20207 not reported 2.19 female alive CESC ## # ... with 1,142 more rows 4.7.4 filter()ing our data filter() is an extremely powerful function. It lets us subset our data according to specific criteria. Let’s filter on a numeric variable, cigarettes_per_day: smoke_complete %&gt;% filter(cigarettes_per_day &lt; 20) ## # A tibble: 1,151 x 6 ## age_at_diagnosis tumor_stage cigarettes_per_day gender vital_status disease ## &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 24477 stage ia 11.0 male dead LUSC ## 2 26615 stage ib 2.19 male dead LUSC ## 3 28171 stage ib 1.64 female dead LUSC ## 4 27154 stage ia 1.10 male alive LUSC ## 5 23370 stage iiia 2.74 female alive LUSC ## 6 19025 stage ib 1.37 male dead LUSC ## 7 26938 stage iv 1.37 male dead LUSC ## 8 28430 stage ib 1.64 male dead LUSC ## 9 30435 stage iib 2.19 male dead LUSC ## 10 24019 stage iv 1.37 male dead LUSC ## # ... with 1,141 more rows We can also filter on a category. But that does require us to know the values of that categorical variable. smoke_complete %&gt;% filter(tumor_stage == &quot;stage iv&quot;) ## # A tibble: 91 x 6 ## age_at_diagnosis tumor_stage cigarettes_per_day gender vital_status disease ## &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 26938 stage iv 1.37 male dead LUSC ## 2 24019 stage iv 1.37 male dead LUSC ## 3 24624 stage iv 2.74 male dead LUSC ## 4 27455 stage iv 3.56 male dead LUSC ## 5 25688 stage iv 2.41 male alive LUSC ## 6 25286 stage iv 2.74 male dead LUSC ## 7 23323 stage iv 3.78 male dead BLCA ## 8 24428 stage iv 3.40 male dead BLCA ## 9 22271 stage iv 2.19 male alive BLCA ## 10 23927 stage iv 1.32 male dead BLCA ## # ... with 81 more rows 4.7.5 Filtering requires a little logic We can chain multiple criteria using the &amp; (AND) or | (OR) operators. But we need to review a little logic before we do this. If I wanted to return patients who were male and stage iv, I would want use an &amp; to chain these criteria together: gender == &quot;male&quot; &amp; tumor_stage == &quot;stage_iv&quot; smoke_complete %&gt;% filter(gender == &quot;male&quot; &amp; tumor_stage == &quot;stage iv&quot;) ## # A tibble: 75 x 6 ## age_at_diagnosis tumor_stage cigarettes_per_day gender vital_status disease ## &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 26938 stage iv 1.37 male dead LUSC ## 2 24019 stage iv 1.37 male dead LUSC ## 3 24624 stage iv 2.74 male dead LUSC ## 4 27455 stage iv 3.56 male dead LUSC ## 5 25688 stage iv 2.41 male alive LUSC ## 6 25286 stage iv 2.74 male dead LUSC ## 7 23323 stage iv 3.78 male dead BLCA ## 8 24428 stage iv 3.40 male dead BLCA ## 9 22271 stage iv 2.19 male alive BLCA ## 10 23927 stage iv 1.32 male dead BLCA ## # ... with 65 more rows If I wanted patients who were male or stage iv I would use an | to chain these criteria together. smoke_complete %&gt;% filter(gender == &quot;male&quot; | tumor_stage == &quot;stage iv&quot;) ## # A tibble: 802 x 6 ## age_at_diagnosis tumor_stage cigarettes_per_day gender vital_status disease ## &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 24477 stage ia 11.0 male dead LUSC ## 2 26615 stage ib 2.19 male dead LUSC ## 3 27154 stage ia 1.10 male alive LUSC ## 4 19025 stage ib 1.37 male dead LUSC ## 5 26938 stage iv 1.37 male dead LUSC ## 6 28430 stage ib 1.64 male dead LUSC ## 7 30435 stage iib 2.19 male dead LUSC ## 8 24019 stage iv 1.37 male dead LUSC ## 9 26813 stage iib 2.74 male alive LUSC ## 10 23972 stage ib 2.19 male alive LUSC ## # ... with 792 more rows Think about it: which of the above two code blocks will return a larger number of patients? 4.7.6 More about Comparison and Logical Operators This is a useful reference for all the different operators (both logical and comparison) that you can use: https://www.datamentor.io/r-programming/operator/ 4.7.7 Selecting columns using select() The final verb we’ll look at is select(). It allows us to select variables from our dataset: smoke_complete %&gt;% select(gender, tumor_stage) ## # A tibble: 1,152 x 2 ## gender tumor_stage ## &lt;chr&gt; &lt;chr&gt; ## 1 male stage ia ## 2 male stage ib ## 3 female stage ib ## 4 male stage ia ## 5 female stage iiia ## 6 male stage ib ## 7 male stage iv ## 8 male stage ib ## 9 male stage iib ## 10 male stage iv ## # ... with 1,142 more rows If we want to select everything but one variable, we can use a - in front of that variable. smoke_complete %&gt;% select(-gender) ## # A tibble: 1,152 x 5 ## age_at_diagnosis tumor_stage cigarettes_per_day vital_status disease ## &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; ## 1 24477 stage ia 11.0 dead LUSC ## 2 26615 stage ib 2.19 dead LUSC ## 3 28171 stage ib 1.64 dead LUSC ## 4 27154 stage ia 1.10 alive LUSC ## 5 23370 stage iiia 2.74 alive LUSC ## 6 19025 stage ib 1.37 dead LUSC ## 7 26938 stage iv 1.37 dead LUSC ## 8 28430 stage ib 1.64 dead LUSC ## 9 30435 stage iib 2.19 dead LUSC ## 10 24019 stage iv 1.37 dead LUSC ## # ... with 1,142 more rows 4.7.8 The difference between filter() and select() One thing to keep in mind is that: filter() works on rows, and select() works on columns Keep that in mind! 4.7.9 Saving our results Let’s save our processed data in the data/ directory. We’ll save it as a csv file, which is short for comma separated value. This is a file type that can be easily imported into excel. processed_data &lt;- smoke_complete %&gt;% select(-gender) %&gt;% filter(cigarettes_per_day &lt; 20) write_excel_csv(x = processed_data, path = &quot;data/processed_data.csv&quot;) 4.8 What you learned today customizing ggplots using theme() making boxplots faceting plots a little bit about factors pipes arrange() filter() select() 4.9 Practice Try out chapters 2 and 3 in the R-Bootcamp: https://r-bootcamp.netlify.app/chapter2 https://r-bootcamp.netlify.app/chapter3 4.10 Acknowledgements This notebook was adapted from material from Kate Hertweck and https://fredhutch.io and from the R-Bootcamp by Ted Laderas and Jessica Minnier. 4.11 Assignment 3 Load the smoke_complete dataset from the data folder. Use filter() to subset those patients who have disease == “LUSC” then save the results to an object called lusc_smokers: smoke_complete &lt;- read_excel(&quot;data/smoke_complete.xlsx&quot;, sheet =1, na= &quot;NA&quot;) Sort lusc_smokers by decreasing tumor_stage: For lusc_smokers, make a boxplot where y = cigarettes_per_day and x = tumor_stage. Modify your plot to facet by gender: Subset smoke_complete to a different set of patients, such as gender == “female”. Make a new faceted plot, this time a scatterplot. You’re free to choose two numeric variables of interest to plot from smoke_complete. Color your plot by disease and facet by vital_status. "],
["part-4-mutate-group-bysummarize.html", "Chapter 5 Part 4: mutate(), group_by()/summarize() 5.1 Learning Objectives 5.2 Getting set up 5.3 mutate() - A confusing name, a powerful dplyr verb 5.4 group_by()/summarize() 5.5 Standardizing variable names: clean_names() 5.6 Assignment 4", " Chapter 5 Part 4: mutate(), group_by()/summarize() 5.1 Learning Objectives Learn and apply mutate() to change the data type of a variable Apply mutate() to calculate a new variable based on other variables in a data.frame. Apply case_when in a mutate() statement to make a continuous variable categorical Apply group_by()/summarize() as a pattern to get summary statistics, including counts, means, and standard deviations within a category. Standardize variable names using clean_names() 5.2 Getting set up # load libraries library(tidyverse) library(readxl) library(janitor) library(here) smoke_complete &lt;- read_excel(here(&quot;data/smoke_complete.xlsx&quot;), sheet=1, na=&quot;NA&quot;) 5.3 mutate() - A confusing name, a powerful dplyr verb So what is mutate? mutate() is one of the most useful dplyr verbs. You can use it to transform data (variables in your data.frame) and add it as a new variable into the data.frame. I tend to think of this much like adding a formula in Excel to calculate the value of a new column based on previous columns. You can do lots of things such as: subtract one column from another convert the units of one column to new units (such as days to years) change the capitalization of categories in a variable recode a continuous variable to be a categorical one 5.3.1 Using mutate to calculate a new variable based on other variables One use for mutate is to do Excel type calculations using other columns on the data. For instance, we might want to calcluate the sum of age_at_diagnosesand days_to_death to get the age_at_death. smoke_complete %&gt;% mutate(age_at_death = age_at_diagnosis + days_to_death) %&gt;% glimpse() ## Rows: 1,152 ## Columns: 21 ## $ primary_diagnosis &lt;chr&gt; &quot;C34.1&quot;, &quot;C34.1&quot;, &quot;C34.3&quot;, &quot;C34.1&quot;, &quot;C3... ## $ tumor_stage &lt;chr&gt; &quot;stage ia&quot;, &quot;stage ib&quot;, &quot;stage ib&quot;, &quot;st... ## $ age_at_diagnosis &lt;dbl&gt; 24477, 26615, 28171, 27154, 23370, 1902... ## $ vital_status &lt;chr&gt; &quot;dead&quot;, &quot;dead&quot;, &quot;dead&quot;, &quot;alive&quot;, &quot;alive... ## $ morphology &lt;chr&gt; &quot;8070/3&quot;, &quot;8070/3&quot;, &quot;8070/3&quot;, &quot;8083/3&quot;,... ## $ days_to_death &lt;dbl&gt; 371, 136, 2304, NA, NA, 345, 716, 2803,... ## $ state &lt;chr&gt; &quot;live&quot;, &quot;live&quot;, &quot;live&quot;, &quot;live&quot;, &quot;live&quot;,... ## $ tissue_or_organ_of_origin &lt;chr&gt; &quot;C34.1&quot;, &quot;C34.1&quot;, &quot;C34.3&quot;, &quot;C34.1&quot;, &quot;C3... ## $ days_to_birth &lt;dbl&gt; -24477, -26615, -28171, -27154, -23370,... ## $ site_of_resection_or_biopsy &lt;chr&gt; &quot;C34.1&quot;, &quot;C34.1&quot;, &quot;C34.3&quot;, &quot;C34.1&quot;, &quot;C3... ## $ days_to_last_follow_up &lt;dbl&gt; NA, NA, 2099, 3747, 3576, NA, NA, 1810,... ## $ cigarettes_per_day &lt;dbl&gt; 10.9589041, 2.1917808, 1.6438356, 1.095... ## $ years_smoked &lt;dbl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, 26,... ## $ gender &lt;chr&gt; &quot;male&quot;, &quot;male&quot;, &quot;female&quot;, &quot;male&quot;, &quot;fema... ## $ year_of_birth &lt;dbl&gt; 1936, 1931, 1927, 1930, 1942, 1953, 193... ## $ race &lt;chr&gt; &quot;white&quot;, &quot;asian&quot;, &quot;white&quot;, &quot;white&quot;, &quot;no... ## $ ethnicity &lt;chr&gt; &quot;not hispanic or latino&quot;, &quot;not hispanic... ## $ year_of_death &lt;dbl&gt; 2004, 2003, NA, NA, NA, 2005, 2006, NA,... ## $ bcr_patient_barcode &lt;chr&gt; &quot;TCGA-18-3406&quot;, &quot;TCGA-18-3407&quot;, &quot;TCGA-1... ## $ disease &lt;chr&gt; &quot;LUSC&quot;, &quot;LUSC&quot;, &quot;LUSC&quot;, &quot;LUSC&quot;, &quot;LUSC&quot;,... ## $ age_at_death &lt;dbl&gt; 24848, 26751, 30475, NA, NA, 19370, 276... 5.3.2 Your Turn Create a variable called cigarettes_total by multiplying cigarettes_per_day by -days_to_birth below: smoke_complete %&gt;% mutate(cigarettes_total = ) 5.3.3 Using mutate to make our character variables into factors Remember factors? Well, we can use mutate() to make a character variable a factor. Let’s convert gender from character into factor. We’ll then pipe the output into glimpse() so you can see the variable types. smoke_complete %&gt;% #reassign the gender variable to be a factor mutate(gender = factor(gender)) %&gt;% glimpse() ## Rows: 1,152 ## Columns: 20 ## $ primary_diagnosis &lt;chr&gt; &quot;C34.1&quot;, &quot;C34.1&quot;, &quot;C34.3&quot;, &quot;C34.1&quot;, &quot;C3... ## $ tumor_stage &lt;chr&gt; &quot;stage ia&quot;, &quot;stage ib&quot;, &quot;stage ib&quot;, &quot;st... ## $ age_at_diagnosis &lt;dbl&gt; 24477, 26615, 28171, 27154, 23370, 1902... ## $ vital_status &lt;chr&gt; &quot;dead&quot;, &quot;dead&quot;, &quot;dead&quot;, &quot;alive&quot;, &quot;alive... ## $ morphology &lt;chr&gt; &quot;8070/3&quot;, &quot;8070/3&quot;, &quot;8070/3&quot;, &quot;8083/3&quot;,... ## $ days_to_death &lt;dbl&gt; 371, 136, 2304, NA, NA, 345, 716, 2803,... ## $ state &lt;chr&gt; &quot;live&quot;, &quot;live&quot;, &quot;live&quot;, &quot;live&quot;, &quot;live&quot;,... ## $ tissue_or_organ_of_origin &lt;chr&gt; &quot;C34.1&quot;, &quot;C34.1&quot;, &quot;C34.3&quot;, &quot;C34.1&quot;, &quot;C3... ## $ days_to_birth &lt;dbl&gt; -24477, -26615, -28171, -27154, -23370,... ## $ site_of_resection_or_biopsy &lt;chr&gt; &quot;C34.1&quot;, &quot;C34.1&quot;, &quot;C34.3&quot;, &quot;C34.1&quot;, &quot;C3... ## $ days_to_last_follow_up &lt;dbl&gt; NA, NA, 2099, 3747, 3576, NA, NA, 1810,... ## $ cigarettes_per_day &lt;dbl&gt; 10.9589041, 2.1917808, 1.6438356, 1.095... ## $ years_smoked &lt;dbl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, 26,... ## $ gender &lt;fct&gt; male, male, female, male, female, male,... ## $ year_of_birth &lt;dbl&gt; 1936, 1931, 1927, 1930, 1942, 1953, 193... ## $ race &lt;chr&gt; &quot;white&quot;, &quot;asian&quot;, &quot;white&quot;, &quot;white&quot;, &quot;no... ## $ ethnicity &lt;chr&gt; &quot;not hispanic or latino&quot;, &quot;not hispanic... ## $ year_of_death &lt;dbl&gt; 2004, 2003, NA, NA, NA, 2005, 2006, NA,... ## $ bcr_patient_barcode &lt;chr&gt; &quot;TCGA-18-3406&quot;, &quot;TCGA-18-3407&quot;, &quot;TCGA-1... ## $ disease &lt;chr&gt; &quot;LUSC&quot;, &quot;LUSC&quot;, &quot;LUSC&quot;, &quot;LUSC&quot;, &quot;LUSC&quot;,... One thing to notice: we are doing something called reassignment here. We’re taking the previous values of our variable (gender), doing something to it (making it a factor), and then reassigning the variable gender to our fixed set of values. Remember when we wanted to decide the order of the categories in the factor? We can assign that order using the levels argument in factor(). To show the order, we can pipe the output into a command called tabyl(), from the janitor package, which is a tidyverse friendly version of table(). smoke_complete %&gt;% #reassign the gender variable to be a factor mutate(gender = factor(gender, levels = c(&quot;female&quot;, &quot;male&quot;))) %&gt;% tabyl(gender) ## gender n percent ## female 366 0.3177083 ## male 786 0.6822917 Notice that the female value goes before the male, which is what we wanted. 5.3.4 Using mutate to make a continuous variable categorical using case_when Say we want to make the cigarettes_per_day into a categorical variable with the values: 0-5 cigarettes/day 6+ cigarettes/day How would we do that? Well, we need to follow the basic pattern for each of our categories: condition ~ category name The left side of the ~ is where we can specify how we define the *category&amp;. The right side of the ~ is where we can specify the category name (as a character). In the example below, cigarettes_per_day &lt;= 5 is our left side, and 0-5 is our right side (our category). We need to do this for each level in our category. smoke_complete %&gt;% mutate( cigarettes_category = case_when( cigarettes_per_day &lt;= 5 ~ &#39;0-5&#39;, cigarettes_per_day &gt; 5 ~ &#39;6+&#39; ) ) %&gt;% mutate(cigarettes_category = factor(cigarettes_category, levels = c(&quot;0-5&quot;, &quot;6+&quot;) ) ) %&gt;% tabyl(cigarettes_category) ## cigarettes_category n percent ## 0-5 1060 0.92013889 ## 6+ 92 0.07986111 5.3.5 Your Turn Modify the code below to recode cigarettes_category to have 3 levels: 0-5 6-10 11+ Hint: you’ll have to chain conditions with a &amp; to get the 6-10 category. smoke_complete %&gt;% mutate( cigarettes_category = case_when( cigarettes_per_day &lt;= 5 ~ &#39;0-5&#39;, cigarettes_per_day &gt; 5 ~ &#39;6+&#39; ) ) %&gt;% mutate(cigarettes_category = factor(cigarettes_category, levels = c(&quot;0-5&quot;, &quot;6+&quot;) ) ) %&gt;% tabyl(cigarettes_category) ## cigarettes_category n percent ## 0-5 1060 0.92013889 ## 6+ 92 0.07986111 5.4 group_by()/summarize() These verbs usually go together and allow you to produce summaries on your data. 5.4.1 summarize() The summarize() verb produces summaries across your data. For example, if I wanted to find the average cigarettes_per_day across all my data, I’d do this: smoke_complete %&gt;% summarize(average_cigarettes = mean(cigarettes_per_day)) ## # A tibble: 1 x 1 ## average_cigarettes ## &lt;dbl&gt; ## 1 2.61 What are the kinds of things that summarize is useful for? Useful functions (from https://dplyr.tidyverse.org/reference/summarise.html) Center: mean(), median() Spread: sd() (standard deviation) Range: min(), max() Position: first(), last(), nth() Count: n(), n_distinct() By itself, summarize() is ok. But it’s really combined with group_by() that it becomes extremely powerful. 5.4.2 group_by()/summarize() These two verbs always go together. group_by() doesn’t do anything by itself, output wise. But what it does is split our data frame into a number of smaller data.frames split out by category. Then we use summarize to do some sort of summary calculation (such as counting or calculating the mean) on these smaller data.frames: For example, if we want to calculate the mean cigarettes_per_day smoked between males and females, we’d do the following: smoke_complete %&gt;% group_by(gender) %&gt;% summarize(mean_cigarettes = mean(cigarettes_per_day)) ## `summarise()` ungrouping output (override with `.groups` argument) ## # A tibble: 2 x 2 ## gender mean_cigarettes ## &lt;chr&gt; &lt;dbl&gt; ## 1 female 2.07 ## 2 male 2.86 5.4.3 group_by()/summarize to calculate mean and standard deviation values Below, we’ll calculate the average number of cigarettes smoked per day for males and females, and the standard deviation. smoke_complete %&gt;% group_by(gender) %&gt;% summarize(mean = mean(cigarettes_per_day), sd = sd(cigarettes_per_day)) ## `summarise()` ungrouping output (override with `.groups` argument) ## # A tibble: 2 x 3 ## gender mean sd ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 female 2.07 1.53 ## 2 male 2.86 2.19 5.4.4 group_by() to count() things What if we want to know the number of subjects in our dataset with each type of disease? We can use the n() function. smoke_complete %&gt;% group_by(disease) %&gt;% summarize(count = n()) ## `summarise()` ungrouping output (override with `.groups` argument) ## # A tibble: 3 x 2 ## disease count ## &lt;chr&gt; &lt;int&gt; ## 1 BLCA 224 ## 2 CESC 92 ## 3 LUSC 836 5.4.5 Your Turn Use group_by()/summarize() to calculate the maximum cigarettes per day within each disease category. smoke_complete %&gt;% group_by(------) %&gt;% summarize(max_cigarettes = -------) 5.5 Standardizing variable names: clean_names() The last package we’ll talk about today is the janitor package. This package adds some really useful functions for cleaning data. The one I use the most is called clean_names(). This will mutate column names into a standard format - all character values will be lowercase and spaces will be converted to underscores. The smoke_complete dataset has already had this function applied to it, but let’s create a smaller example dataset where this wouldn’t be the case. smoke_bad_colnames &lt;- read_csv(&quot;data/smoke_bad_colnames.csv&quot;) ## Parsed with column specification: ## cols( ## `primary diagnosis` = col_character(), ## `tumor Stage` = col_character(), ## `Age at Diagnosis` = col_double(), ## vitalSTATUS = col_character() ## ) smoke_bad_colnames ## # A tibble: 1,152 x 4 ## `primary diagnosis` `tumor Stage` `Age at Diagnosis` vitalSTATUS ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 C34.1 stage ia 24477 dead ## 2 C34.1 stage ib 26615 dead ## 3 C34.3 stage ib 28171 dead ## 4 C34.1 stage ia 27154 alive ## 5 C34.1 stage iiia 23370 alive ## 6 C34.3 stage ib 19025 dead ## 7 C34.3 stage iv 26938 dead ## 8 C34.1 stage ib 28430 dead ## 9 C34.1 stage iib 30435 dead ## 10 C34.9 stage iv 24019 dead ## # ... with 1,142 more rows Ack! These column names have spaces, inconsistent capitalization, which make these difficult to work with. So let’s use clean_names() to fix this: smoke_good_colnames &lt;- smoke_bad_colnames %&gt;% clean_names() smoke_good_colnames ## # A tibble: 1,152 x 4 ## primary_diagnosis tumor_stage age_at_diagnosis vital_status ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 C34.1 stage ia 24477 dead ## 2 C34.1 stage ib 26615 dead ## 3 C34.3 stage ib 28171 dead ## 4 C34.1 stage ia 27154 alive ## 5 C34.1 stage iiia 23370 alive ## 6 C34.3 stage ib 19025 dead ## 7 C34.3 stage iv 26938 dead ## 8 C34.1 stage ib 28430 dead ## 9 C34.1 stage iib 30435 dead ## 10 C34.9 stage iv 24019 dead ## # ... with 1,142 more rows By default, clean_names() converts to snake case (spaces between words are replaced by an underscore _). clean_names() will help you standardize your dataset’s column names. 5.6 Assignment 4 Load the smoke_complete dataset from the data folder. Determine which tissue/organ of origin occurs most frequently in smoke_complete. (Hint: use both group_by()/summarize() and arrange().) smoke_complete %&gt;% Create a new dataset called smoke_filtered that only contains subjects with tissue_or_organ_of_origin of C34.3. Use glimpse() on smoke_filtered. smoke_filtered &lt;- smoke_complete %&gt;% glimpse(smoke_filtered) For subjects in smoke_filtered, make a new variable called age_years by converting age_at_diagnosis from days to years. smoke_filtered &lt;- smoke_filtered %&gt;% mutate(age_years = _______ * _____) Make a new variable called age_category using case_when() from age_years in smoke_filtered. Make age_category a factor with the following levels: 0-40 years old 40-55 years old 55-70 years old 70+ years old smoke_filtered &lt;- smoke_filtered %&gt;% mutate(age_category = case_when(age_years &lt;= 40 ~ &quot;0-40&quot;, ) ) %&gt;% mutate(age_category = factor(age_category, levels = c(&quot;0-40&quot;, ) ) ) Create a scatterplot using geom_point() demonstrating the correlation (if any) between the categorical variable age_at_diagnosis versus cigarettes_per_day. ggplot(smoke_complete) + aes(x = , y= ) + geom_point() "],
["more-about-factors.html", "Chapter 6 More about Factors 6.1 Making a factor variable out of disease 6.2 Using the character variable 6.3 Compare to the factor variable 6.4 Another thing about factors 6.5 fct_rev() - reversing the order of a factor 6.6 fct_reorder() 6.7 fct_collapse 6.8 Other really useful forcats functions", " Chapter 6 More about Factors This was part of a impromptu session learning about factors. # load libraries library(tidyverse) library(readxl) library(janitor) library(forcats) smoke_complete &lt;- read_excel(&quot;data/smoke_complete.xlsx&quot;, sheet=1, na=&quot;NA&quot;) 6.1 Making a factor variable out of disease We’re adding a fourth value, BRCA to our levels here. smoke_complete2 &lt;- smoke_complete %&gt;% mutate(disease_factor = factor(disease, levels = c(&quot;LUSC&quot;, &quot;CESC&quot;, &quot;BLCA&quot;, &quot;BRCA&quot;) ) ) 6.2 Using the character variable ggplot(smoke_complete2) + aes(x=disease, y=cigarettes_per_day) + geom_boxplot() 6.3 Compare to the factor variable ggplot(smoke_complete2) + aes(x=disease_factor, y=cigarettes_per_day) + geom_boxplot() 6.4 Another thing about factors Factor levels also specify the permissible values. In this example, LUSC and BRCA are the permissible values. We pass a character vector into them, and you can see those values (BLCA, CESC) are recoded as NAs character_vector &lt;- c(&quot;LUSC&quot;, &quot;LUSC&quot;, &quot;BRCA&quot;, &quot;BLCA&quot;, &quot;BRCA&quot;, &quot;CESC&quot;, &quot;CESC&quot;) factor_vector &lt;- factor(character_vector, levels=c(&quot;LUSC&quot;, &quot;BRCA&quot;)) factor_vector ## [1] LUSC LUSC BRCA &lt;NA&gt; BRCA &lt;NA&gt; &lt;NA&gt; ## Levels: LUSC BRCA 6.5 fct_rev() - reversing the order of a factor Very useful when using factors on the y-axis, because the default ordering is first value at the bottom, rather than first value at the top. library(forcats) #fct_rev() smoke_complete3 &lt;- smoke_complete2 %&gt;% mutate(disease_rev = fct_rev(disease_factor)) #show original factor ggplot(smoke_complete3) + aes(y=disease_factor, x=cigarettes_per_day) + geom_boxplot() #show factor with reversed order ggplot(smoke_complete3) + aes(y=disease_rev, x=cigarettes_per_day) + geom_boxplot() 6.6 fct_reorder() fct_reorder() lets you reorder factors by another numeric variable. library(forcats) #fct_rev() smoke_complete3 &lt;- smoke_complete2 %&gt;% mutate(disease_reorder = fct_reorder(disease_factor, cigarettes_per_day)) ggplot(smoke_complete3) + aes(y=disease_reorder, x=cigarettes_per_day) + geom_jitter() 6.7 fct_collapse fct_collapse() lets you collapse multiple categories into one category. smoke_complete3 %&gt;% mutate(disease_collapse = fct_collapse( disease_factor, other = c(&quot;BLCA&quot;, &quot;CESC&quot;), LUSC = c(&quot;LUSC&quot;) )) %&gt;% tabyl(disease_collapse) ## disease_collapse n percent ## LUSC 836 0.7256944 ## other 316 0.2743056 ## BRCA 0 0.0000000 6.8 Other really useful forcats functions fct_recode() - lets you recode values manually. fct_other() - lets you define what categories are in an other variable. "],
["part-5-doing-useful-things-with-multiple-tables.html", "Chapter 7 Part 5: Doing useful things with multiple tables 7.1 Learning Objectives 7.2 Getting set up 7.3 bind_rows() 7.4 Joining Tables 7.5 Making your data long: pivot_longer() 7.6 Assignment", " Chapter 7 Part 5: Doing useful things with multiple tables 7.1 Learning Objectives Learn and apply bind_rows() to combine rows from two or more datasets Learn about the different kinds of joins and how they merge data Apply inner_join() and left_join() to join tables on columns Standardize variable names using clean_names() Utilize pivot_longer() to make a wide dataset long 7.2 Getting set up library(tidyverse) ## -- Attaching packages ---------------------------------- tidyverse 1.3.0 -- ## v ggplot2 3.3.1 v purrr 0.3.4 ## v tibble 3.0.1 v dplyr 1.0.0 ## v tidyr 1.1.0 v stringr 1.4.0 ## v readr 1.3.1 v forcats 0.5.0 ## -- Conflicts ------------------------------------- tidyverse_conflicts() -- ## x dplyr::filter() masks stats::filter() ## x dplyr::lag() masks stats::lag() library(readxl) library(janitor) ## ## Attaching package: &#39;janitor&#39; ## The following objects are masked from &#39;package:stats&#39;: ## ## chisq.test, fisher.test library(here) ## here() starts at C:/Code/ready_for_r_site/static/book 7.3 bind_rows() 7.3.1 Motivation for bind_rows() Imagine that your lab is part of a large consortium studying the effects of smoking. As the lead data scientist, you’ve helped oversee the collection and documentation several observations for many variables of interest. Many labs within the consortium have accumulated data, and not all were following the guidelines you set for the tables. smoke_1 &lt;- read_excel(here(&#39;data/smoke_1.xlsx&#39;), sheet=1, na=&quot;NA&quot;) smoke_1 &lt;- smoke_1[1:5,] smoke_1 ## # A tibble: 5 x 5 ## primary_diagnosis tumor_stage age_at_diagnosis vital_status morphology ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; ## 1 C34.1 stage ia 24477 dead 8070/3 ## 2 C34.1 stage ib 26615 dead 8070/3 ## 3 C34.3 stage ib 28171 dead 8070/3 ## 4 C34.1 stage ia 27154 alive 8083/3 ## 5 C34.1 stage iiia 23370 alive 8070/3 smoke_2 &lt;- read_excel(here(&#39;data/smoke_2.xlsx&#39;), sheet=1, na=&quot;NA&quot;) smoke_2 &lt;- smoke_2[1:5,] smoke_2 ## # A tibble: 5 x 5 ## primary_diagnosis tumor_stage age_at_diagnosis vital_status morphology ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; ## 1 C67.9 stage iv 17682 alive 8120/3 ## 2 C67.9 stage ii 19776 alive 8120/3 ## 3 C67.9 stage iii 23631 alive 8120/3 ## 4 C67.9 stage iv 26546 dead 8120/3 ## 5 C67.9 stage iii 24534 dead 8120/3 smoke_3 &lt;- read_excel(here(&#39;data/smoke_3.xlsx&#39;), sheet=1, na=&quot;NA&quot;) smoke_3 &lt;- smoke_3[1:5,] smoke_3 ## # A tibble: 5 x 5 ## VITAL_STATUS `Age at Diagnosis` tumorStage Morphology primary_diagnosis ## &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 alive 17682 stage iv 8120/3 C67.9 ## 2 alive 19776 stage ii 8120/3 C67.9 ## 3 alive 23631 stage iii 8120/3 C67.9 ## 4 dead 26546 stage iv 8120/3 C67.9 ## 5 dead 24534 stage iii 8120/3 C67.9 7.3.2 Binding two tables together How can you combine datasets from individual labs? Enter bind_rows()… smoke_1 %&gt;% bind_rows(smoke_2) ## # A tibble: 10 x 5 ## primary_diagnosis tumor_stage age_at_diagnosis vital_status morphology ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; ## 1 C34.1 stage ia 24477 dead 8070/3 ## 2 C34.1 stage ib 26615 dead 8070/3 ## 3 C34.3 stage ib 28171 dead 8070/3 ## 4 C34.1 stage ia 27154 alive 8083/3 ## 5 C34.1 stage iiia 23370 alive 8070/3 ## 6 C67.9 stage iv 17682 alive 8120/3 ## 7 C67.9 stage ii 19776 alive 8120/3 ## 8 C67.9 stage iii 23631 alive 8120/3 ## 9 C67.9 stage iv 26546 dead 8120/3 ## 10 C67.9 stage iii 24534 dead 8120/3 bind_rows() allows you to append one dataset to the bottom of another dataset. We can see that smoke_1 contained 549 rows and smoke_2 contained 603 rows. After using bind_rows(), we now have a single dataset containing 1152 rows. That’s all pretty cool, until you meet a rogue lab. This lab almost seems as if they’ve gone out of their way to make things difficult. Rather than putting columns in the standard order specified, they’ve switched them around. Even worse, they’ve named the columns differently! If there are only a few columns, sure, we could manually fix this. But what if this was RNASeq data, with thousands of column names to fix?! Well, let’s remember we still have clean_names(). That can at least help us get the column names into the standard format. smoke_3_clean &lt;- smoke_3 %&gt;% clean_names() Our column names are at least the same, but they’re still out of order! If we append smoke_3_clean to smoke_1, vital_status will be appened under primary_diagnosis, age_at_diagnosis will be appended under tumor_stage, and so on. Do we need to reorder the columns before we append them? smoke_1 %&gt;% bind_rows(smoke_3_clean) ## # A tibble: 10 x 5 ## primary_diagnosis tumor_stage age_at_diagnosis vital_status morphology ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; ## 1 C34.1 stage ia 24477 dead 8070/3 ## 2 C34.1 stage ib 26615 dead 8070/3 ## 3 C34.3 stage ib 28171 dead 8070/3 ## 4 C34.1 stage ia 27154 alive 8083/3 ## 5 C34.1 stage iiia 23370 alive 8070/3 ## 6 C67.9 stage iv 17682 alive 8120/3 ## 7 C67.9 stage ii 19776 alive 8120/3 ## 8 C67.9 stage iii 23631 alive 8120/3 ## 9 C67.9 stage iv 26546 dead 8120/3 ## 10 C67.9 stage iii 24534 dead 8120/3 Well look at that. bind_rows() takes care of the out-of-order columns for us! 7.4 Joining Tables 7.4.1 Motivation You have data on patients from two sources - one are labs, and they supply patient ids. The second source comes from an electronic medical record. How do you combine these two into a single table? 7.4.2 Naming conventions source: https://github.com/gadenbuie/tidyexplain Before we talk about joins, we need to define some terms. left table and right table: Whenever we join two tables, we will have a left table (in this case, the x table) and a right table (in this case, the y table). key: In order to join the two tables, we have to somehow map the rows of our left table (x) with the rows of our other table (y). We do this by joining together rows with a common variable. In our case, we need to join rows based on the first column in both tables. The column that we join on is called a key. source: https://github.com/gadenbuie/tidyexplain In the above example, we see that there is a row in x whose key is 2, and there is a row in y whose key is 2 as well. So it makes sense to join these two rows together. So, by matching the rows with identical keys, we can put together a table that incorporates information from both tables. 7.4.3 Inner Joins source: https://github.com/gadenbuie/tidyexplain With an inner join, we are matching rows based on our key. If there is not a match in both tables, we don’t include the row with that key. In the example above, we don’t keep row 3 in table x or row 4 in table y. 7.4.4 Joining Syntax Keeping these terms in mind, let’s look at the syntax for joining two tables together. inner_join(table_x, table_y, by = c(key_column_x = key_column_y) ) If we just wanted to join the two tables, the above is enough. We first specify the left table (table_x), and the right table (table_y). Note the by argument. This is the argument where we specify which column in each table contains our key. 7.4.5 The more dplyr way to do joins The more dplyr way to do joins is below: #start with left table table_x %&gt;% #join left table with right table inner_join(y = table_y, #point out the key column in each table by = c(key_column_x= key_column_y) ) We start with our left table, table_x. The main difference is that we don’t need to specify the x argument in inner_join(), because we are piping table_x as the first argument of inner_join(). 7.4.6 Left Joins Left joins are a little different. In a left join, we keep all the rows in the left table regardless of whether there is a match in the right table. In the example above, we keep row 3 in table x even though it doesn’t have a match in table y. Because there is no information from the right table, these rows will have an NA. That is, the information is missing for the columns that come from the right table. 7.4.7 Let’s work through an example Say we have a set of patients. We want to join their information with their labs, in particular a white blood cell count (a WBC). We also need to know whether there are patients in our set who haven’t gotten a CBC. Because the lab system isn’t part of the electronic health record, we’ll need to make a join on the patient table to the lab table. patient_table &lt;- read_excel(&quot;data/patient_example.xlsx&quot;, sheet = 1) wbc_table &lt;- read_excel(&quot;data/patient_example.xlsx&quot;, sheet = 2) Let’s look at patient_table, which we’ll use as our left table: patient_table ## # A tibble: 4 x 4 ## patient_id first_name last_name age ## &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 2333 Scarlet O&#39;Hara 75 ## 2 7359 Neil O&#39;Hara 30 ## 3 1414 Ivy Lee 43 ## 4 8424 May Lynne 14 Here is wbc_table, which we’ll use as our right table: wbc_table ## # A tibble: 4 x 2 ## patient_id wbc_value ## &lt;dbl&gt; &lt;dbl&gt; ## 1 2333 5000 ## 2 7359 12000 ## 3 1414 6000 ## 4 4409 4000 Let’s do an inner_join(): patient_table %&gt;% inner_join(y = wbc_table, by = c(&quot;patient_id&quot; = &quot;patient_id&quot;)) ## # A tibble: 3 x 5 ## patient_id first_name last_name age wbc_value ## &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 2333 Scarlet O&#39;Hara 75 5000 ## 2 7359 Neil O&#39;Hara 30 12000 ## 3 1414 Ivy Lee 43 6000 7.4.8 Your Turn Modify the code below to do a left_join() on patient_table and wbc_table. patient_table %&gt;% inner_join(y = wbc_table, by = c(&quot;patient_id&quot; = &quot;patient_id&quot;)) ## # A tibble: 3 x 5 ## patient_id first_name last_name age wbc_value ## &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 2333 Scarlet O&#39;Hara 75 5000 ## 2 7359 Neil O&#39;Hara 30 12000 ## 3 1414 Ivy Lee 43 6000 Which patient in patient_table didn’t get a WBC? 7.5 Making your data long: pivot_longer() The last thing we’ll talk about is the difference between the wide data format and the long data format. A really common format in bioinformatics is the expression matrix. In an expression matrix, the rows correspond to different genes and the columns correspond to different samples. expression_example &lt;- read_excel(&quot;data/expression_example.xlsx&quot;, sheet=1) expression_example ## # A tibble: 4 x 5 ## gene_symbol tcga_110 tcga_332 tcga_548 tcga_523 ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 PTEN 4.1 5.6 2.2 2.1 ## 2 MTOR 5.6 6.6 3.1 3.2 ## 3 RKIP 1 1.4 1.2 1.2 ## 4 KCNJ9 2.3 1.1 0.5 0.2 7.5.1 However… This format isn’t super useful for a lot of data manipulations. It’s because the columns correspond to samples, and this prevents us from plotting things like PTEN expression across the samples. This kind of data is in a format that is called wide format. What we need to do is collapse the numerical values into a single column. 7.5.2 The magic of pivot_longer() pivot_longer() is the function that will let us make our wide data long. It takes three arguments cols - the columns to collapse. We haven’t talked about tidyselect verbs, but there are a few that let you select columns based on naming criteria. Here we’re using the starts_with() selector to grab the columns that begin with tcga names_to - the name of the column where the labels will be consolidated to values_to - the name of the column where the values in the columns in the wide data will be consolidated to. expression_long &lt;- expression_example %&gt;% pivot_longer(cols= starts_with(&quot;tcga&quot;), names_to = &quot;sample&quot;, values_to = &quot;expression&quot;) expression_long ## # A tibble: 16 x 3 ## gene_symbol sample expression ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 PTEN tcga_110 4.1 ## 2 PTEN tcga_332 5.6 ## 3 PTEN tcga_548 2.2 ## 4 PTEN tcga_523 2.1 ## 5 MTOR tcga_110 5.6 ## 6 MTOR tcga_332 6.6 ## 7 MTOR tcga_548 3.1 ## 8 MTOR tcga_523 3.2 ## 9 RKIP tcga_110 1 ## 10 RKIP tcga_332 1.4 ## 11 RKIP tcga_548 1.2 ## 12 RKIP tcga_523 1.2 ## 13 KCNJ9 tcga_110 2.3 ## 14 KCNJ9 tcga_332 1.1 ## 15 KCNJ9 tcga_548 0.5 ## 16 KCNJ9 tcga_523 0.2 7.5.3 Doing things with the long data Now that we have our long data, we can do our usual kinds of plotting. ggplot(expression_long) + aes(x=gene_symbol, y=expression, fill=gene_symbol) + geom_boxplot() We can even make expression heatmaps with geom_tile. ggplot(expression_long) + aes(x=sample, y= gene_symbol, fill=expression) + geom_tile() 7.5.4 pivot_wider() exists too! And part of your assignment will be to figure out how to use it. 7.6 Assignment Use bind_rows() to bind all three smoke datasets (smoke_1, smoke_2, and smoke_3) together. Hint: you’ll have to do two bind_row() operations. Take a look at the patient and patient_encounter tables loaded below. patient &lt;- read_csv(&quot;data/patient_example.csv&quot;) ## Parsed with column specification: ## cols( ## patient_id = col_double(), ## GENDER = col_character(), ## First_name = col_character(), ## Last_name = col_character(), ## status = col_double(), ## Insurance_ID = col_double(), ## race = col_double(), ## postalcode = col_double(), ## riskCat = col_character(), ## riskscore = col_double() ## ) patient_encounter &lt;- read_csv(&quot;data/patient_enc_example.csv&quot;) ## Parsed with column specification: ## cols( ## patientid = col_double(), ## Event_ID = col_double(), ## outcome = col_character(), ## Admit_date = col_character(), ## Admit_source = col_character() ## ) How many rows does each table have? nrow() nrow() Write a inner_join() and assign it to inner_patient with patient as the left table patient_encounter as the right table joining on the approriate columns (look at the column names carefully!) inner_patient &lt;- patient %&gt;% inner_join(y = ____, by = c()) inner_patient How many rows does inner_patient have? Do a left_join of the two tables with the same criteria as above. Assign it to left_patient. Count the number of rows in left_patient. Is it what you expected? left_patient &lt;- patient %&gt;% left_join() nrow(left_patient) Look up the documentation for pivot_wider. Transform expression_longer back to a wide format, but this time with columns as genes and rows as samples. Hint: Always look at the examples in the documentation! They’ll help you. expression_longer %&gt;% pivot_wider(id_cols = , names_from = , values_from) "],
["simple-statistics-with-broom.html", "Chapter 8 Simple Statistics with broom 8.1 Learning Objectives 8.2 Getting Help on Errors 8.3 Caveat about statistics 8.4 Introducing tidymodels 8.5 T-tests 8.6 How Correlated are the Three Variables? 8.7 Let’s build a simple linear model 8.8 Analysis of Variance (ANOVA) (Optional)", " Chapter 8 Simple Statistics with broom 8.1 Learning Objectives Learn about errors and warnings and where to ask for help Learn some basic Exploratory Data Analysis techniques Learn a basic analysis workflow for statistical modeling Learn about formulas and how to specify models using them Learn about t Tests and how to apply them to your dataset Learn and apply linear regression models Learn and apply Analysis of Variance (ANOVA) 8.2 Getting Help on Errors 8.2.1 Understanding the difference between warnings and errors A warning is an indication that the data or arguments isn’t quite what the function expected. You can usually run the code, but you should be careful about it and verify the output. An error means that the code can’t execute at all given what you have given the function. Errors can be difficult to understand, which is why 8.2.2 Googling is StandaRd pRactice foR eRrors The first thing I do when I encounter an error is to search for the error. I usually start with Google. I don’t know everything, and the odds are that I made a mistake in understanding the documentation. There are some resources that I especially check (in order): RStudio Community (for tidyverse): https://community.rstudio.com/ Stack Overflow: http://stackoverflow.com/ Biostars (for Bioinformatics): https://www.biostars.org/ The package’s github page (especially issues) 8.2.3 Where do I ask for help? I’m trying to be as helpful as I can, but I can’t answer all of your questions. The following communities are extremely helpful to beginners: R for Data Science Community: https://r4ds.slack.com/ RStudio Community: https://community.rstudio.com/ 8.3 Caveat about statistics This is not meant to be a comprehensive course in statistics. We want to show you some basic techniques, but you will need to dig further. Danielle Navarro’s Learning Statistics with R is excellent and talks much more about statistics: https://learningstatisticswithr.com/ 8.4 Introducing tidymodels We will be using the broom package from the tidymodels set of packages to make the modeling easier to work with. tidymodels attempts to unify all of the various modeling packages in a consistent interface. broom works mostly with the output of models. One of the problems with R is that the many modeling packages are not consistent to work with. It can be just as difficult to get a p-value out of a model as it is to run it on some data! broom simpliflies this a lot. There are 3 main functions in broom: tidy() - This is where you get most of the output you want, including coefficients and p-values glance() - additional measures on your model, including R-squared, log likelihood, and AIC/BIC augment() - make predictions with your model using new data We will mostly use tidy() and glance() for right now. 8.5 T-tests 8.5.1 The Dataset A study by Goran et.al (1996) examined the accuracy of some widely used body-composition techniques for children using three different methods: dual-energy X-ray absorptiometry (dxa) technique, skin-fold thickness (st), bioelectric resistance (br). Subjects were children between 4 and 10 years old. Data were collected on 98 subjects (49 males and 49 females). One purpose of the study was to determine whether there was a difference in fat mass measurements using DXA (considered the gold standard method) compared to the skin-fold thickness method. We also wish to determine if DXA levels are significantly different between males and females. 8.5.2 Getting set up library(tidyverse) library(broom) library(readxl) library(janitor) library(GGally) library(broom) body_comp &lt;- read_csv(&#39;data/body_composition.csv&#39;, na=&quot;NA&quot;) %&gt;% clean_names() %&gt;% mutate(gender = factor(gender, levels=c(&quot;1&quot;, &quot;0&quot;))) head(body_comp) ## # A tibble: 6 x 4 ## dxa st br gender ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;fct&gt; ## 1 3.65 4.55 4.26 1 ## 2 3.92 2.82 6.09 0 ## 3 7.53 3.89 5.12 0 ## 4 6.24 5.49 8.04 0 ## 5 10.6 10.5 14.2 0 ## 6 9.58 11.2 12.4 0 8.5.3 Exploratory Data Analysis Before we do any statistical tests on our data, we should first visualize it. Since our ultimate goal is to examine the differences between bodyfat measurement methods, let’s create boxplots that illustrate this difference, if any. Notice that the aes() for ggplot() only accepts one x value and one y value, but we have three columns we’d like to compare (dxa, st, br). So, we need to convert our data to long format using pivot_longer(). body_comp_long &lt;- body_comp %&gt;% pivot_longer(cols = c(&#39;dxa&#39;, &#39;st&#39;, &#39;br&#39;), names_to = &#39;method&#39;, values_to = &#39;body_fat_percentage&#39;) head(body_comp_long) ## # A tibble: 6 x 3 ## gender method body_fat_percentage ## &lt;fct&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 1 dxa 3.65 ## 2 1 st 4.55 ## 3 1 br 4.26 ## 4 0 dxa 3.92 ## 5 0 st 2.82 ## 6 0 br 6.09 Now that we’ve done that, we can set x = method and y = body_fat_percentage. ggplot(body_comp_long) + aes(x = method, y = body_fat_percentage, fill = method) + geom_boxplot() + geom_jitter(color=&quot;grey&quot;) It appears that our measurements are close to one another, but there are some noticable differences. 8.5.4 t-test Briefly, a t-test should be used when examining whether the mean between two groups are similar This means that the measurements must be numeric (there are other tests for categorical data). The null hypothesis for a t-test is that the two means are equal, and the alternative is that they are not. One purpose of the study was to determine whether there was a difference in fat mass measurements using dxa (considered the gold standard method) compared to the skin-fold thickness method (st). Below, we will use a paired t-test. Paired simply means that each group (dxa and st) each contain measurements for the same subject on corresponding rows. If body fat measurements were collected using dxa for children in Group A and st for a separate set of children in Group B, then we would not use a paired t-test. HYPOTHESIS: There is a difference in mean fat mass measurements between the DXA and skin-fold thickness (ST) methods. NULL HYPOTHESIS: There is no difference in mean fat mass measurements between the two methods. We also need to set a significance threshold. We’ll set it at 0.05. body_comp_dxa_st &lt;- body_comp_long %&gt;% filter(method %in% c(&quot;dxa&quot;, &quot;st&quot;)) tidy_output2 &lt;- t.test(body_comp$dxa, body_comp$st, paired=TRUE) %&gt;% tidy() tidy_output &lt;- t.test(body_fat_percentage ~ method, paired=TRUE, data=body_comp_dxa_st) %&gt;% tidy() tidy_output2 ## # A tibble: 1 x 8 ## estimate statistic p.value parameter conf.low conf.high method alternative ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; ## 1 -0.207 -1.78 0.0774 97 -0.438 0.0232 Paired t-~ two.sided We see that p.value is equal to ~0.634; this means we cannot reject the null hypothesis (i.e., the difference in body fat measurements between dxa and st are not statistically different from one another). 8.5.5 Your Turn Try running t.test, comparing dxa and br using body_comp_long. Hint: You’ll have to filter the method like above. body_comp &lt;- body_comp %&gt;% tidyr::drop_na() body_comp_long &lt;- body_comp %&gt;% pivot_longer(cols = c(&#39;dxa&#39;, &#39;st&#39;, &#39;br&#39;), names_to = &#39;method&#39;, values_to = &#39;body_fat_percentage&#39;) body_comp_dxa_sf &lt;- body_comp_long %&gt;% filter(method %in% c(&quot;dxa&quot;, &quot;br&quot;)) tidy_output &lt;- t.test(body_fat_percentage ~ method, paired=TRUE, data=body_comp_dxa_sf) %&gt;% tidy() tidy_output 8.6 How Correlated are the Three Variables? Another question we’d like to check is whether the measurements are correlated or not. That is, can we reliably predict dxa from st? Let’s generate a pairs plot, which can be a useful way of visualizing correlated variables. We can do this by using ggpairs(), which is in the GGally package (not part of the tidyverse): GGally::ggpairs(body_comp, aes(color=gender)) ## Warning in ggally_statistic(data = data, mapping = mapping, na.rm = na.rm, : ## Removing 1 row that contained a missing value ## Warning in ggally_statistic(data = data, mapping = mapping, na.rm = na.rm, : ## Removing 1 row that contained a missing value ## Warning: Removed 1 rows containing missing values (geom_point). ## Warning: Removed 1 rows containing missing values (geom_point). ## Warning: Removed 1 rows containing non-finite values (stat_density). ## Warning: Removed 1 rows containing non-finite values (stat_boxplot). ## Warning: Removed 1 rows containing non-finite values (stat_bin). We can generate a scatterplot with a trend line using a geom called geom_smooth(). We need to add the arguments method and se (short for standard error). body_comp %&gt;% ggplot() + aes(x=dxa, y=st) + geom_point() + geom_smooth(method = &quot;lm&quot;, se = FALSE) ## `geom_smooth()` using formula &#39;y ~ x&#39; 8.6.1 Your Turn Try setting se to TRUE. What does it add to the graph? body_comp %&gt;% ggplot() + aes(x=dxa, y=st) + geom_point() + geom_smooth( se = TRUE) ## `geom_smooth()` using method = &#39;loess&#39; and formula &#39;y ~ x&#39; 8.7 Let’s build a simple linear model We’ve established that there is a correlation between dxa and st. Can we use st to predict dxa? y = ax + b lm(dxa ~ st, data=body_comp) %&gt;% tidy() ## # A tibble: 2 x 5 ## term estimate std.error statistic p.value ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 (Intercept) 0.275 0.215 1.28 2.05e- 1 ## 2 st 0.903 0.0367 24.6 3.17e-43 The predicted line through the data is: dxa = 0.295 + 0.903 * st 8.7.1 Adding another variable What if we included gender in our model? Our model can accept factors as inputs. copy_number &lt;- c(&quot;1&quot;, &quot;0&quot;, &quot;2&quot;) lm(dxa ~ st + gender, data=body_comp) %&gt;% tidy() ## # A tibble: 3 x 5 ## term estimate std.error statistic p.value ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 (Intercept) 0.0646 0.224 0.288 7.74e- 1 ## 2 st 0.888 0.0362 24.5 6.93e-43 ## 3 gender0 0.577 0.222 2.60 1.09e- 2 In this case, gender is a useful predictor of dxa, since the p-value is less than our threshold of 0.05. However, if we did use the equation, it would correspond to this equation: dxa = 0.097 + 0.889 * st + 0.536 * gender0 The factor gender here is recoded as a “dummy” variable, and reading it is a little confusing. Note that it says gender0 and not gender. That’s because it’s coding gender = 0 as 1 here, and 0, if gender is 1. Dummy variables are very confusing. http://www.sthda.com/english/articles/40-regression-analysis/163-regression-with-categorical-variables-dummy-coding-essentials-in-r/ 8.7.2 Your Turn Try adding br as a term in the model. How does it change the p-value of st? lm(dxa ~ st + br, data=body_comp) %&gt;% tidy() ## # A tibble: 3 x 5 ## term estimate std.error statistic p.value ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 (Intercept) 0.111 0.208 0.532 5.96e- 1 ## 2 st 0.699 0.0683 10.2 5.78e-17 ## 3 br 0.213 0.0615 3.46 8.20e- 4 8.8 Analysis of Variance (ANOVA) (Optional) We’ve determined that there isn’t a statistical difference between dxa and st, but we also meausured bodyfat using bioelectric resistance, br. Maybe we should see if it measures differently from the other two methods. Because a t-test can only be used to measure the differences in means between two groups, we’d have to use multiple t-tests. But wait, should we do that right away? No, because we’ll run into the Multiple Comparisons Problem! So rather than performing multiple t-tests, we first want to examine whether any of the groups is different from the rest of the groups using an ANOVA (aov()). aov() uses the formula interface. The tilde (~) can be translated to “is a function of”. Below, we are testing whether body fat percentage is a function of the type of body fat measurement method. We pipe the output of aov() to summary() to get a clearer idea of the output of the ANOVA. aov(body_fat_percentage ~ method, data = body_comp_long) %&gt;% tidy() ## # A tibble: 2 x 6 ## term df sumsq meansq statistic p.value ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 method 2 40.7 20.3 2.01 0.136 ## 2 Residuals 290 2935. 10.1 NA NA The value p.value is what we’re interested in. Because it is greater than 0.05, we can conclude that none of the measurement methods is significantly different from the others, and there is no reason to perform multiple t-tests on our dataset. 8.8.1 Post-hoc Tests Now if our F statistic probability had come back below 0.05, then we could perform multiple post-hoc t-tests. However, we would need to account for false positives by using a correction method (e.g., Bonferroni). pairwise.t.test(body_comp_long$body_fat_percentage, body_comp_long$method, p.adjust = &quot;bonferroni&quot;) %&gt;% tidy() ## # A tibble: 3 x 3 ## group1 group2 p.value ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 dxa br 0.167 ## 2 st br 0.432 ## 3 st dxa 1 8.8.2 More about the Multiple Testing Problem Consider what a p-value of 0.05 actually means: if a test is performed at the 0.05 level and the corresponding null hypothesis is true, there is only a 5% chance of incorrectly rejecting the null hypothesis. This is an okay risk to take given that we are only performing the t-test once. But if we were to perform the t-test 1,000 times on data where all null hypotheses were true, the expected number of incorrect rejections (also known as false positives or Type I errors) would be 50! 8.8.3 Acknowledgements Written by Aaron Coyner and Ted Laderas "]
]
